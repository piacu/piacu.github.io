---

layout: post
title: "[Java] 코드트리: 코드트리 빵"
tags: [algorithm, codetree, java, 코드트리, 코드트리 빵]

---

최근 코드트리 빵이 전국적으로 인기를 얻어 편의점에서 해당 빵을 구하기 힘들어졌습니다. 빵을 구하고자 하는 m명의 사람이 있는데, 1번 사람은 정확히 1분에, 2번 사람은 정확히 2분에, ..., m번 사람은 정확히 m 분에 각자의 베이스캠프에서 출발하여 편의점으로 이동하기 시작합니다. 사람들은 출발 시간이 되기 전까지 격자 밖에 나와있으며, 사람들이 목표로 하는 편의점은 모두 다릅니다. 이 모든 일은 n*n 크기의 격자 위에서 진행됩니다.

코드트리 빵을 구하고 싶은 사람들은 다음과 같은 방법으로 움직입니다. 이 3가지 행동은 총 1분 동안 진행되며, 정확히 1, 2, 3 순서로 진행되어야 함에 유의합니다.

1. 격자에 있는 사람들 모두가 본인이 가고 싶은 편의점 방향을 향해서 1 칸 움직입니다. 최단거리로 움직이며 최단 거리로 움직이는 방법이 여러가지라면 ↑, ←, →, ↓ 의 우선 순위로 움직이게 됩니다. 여기서 최단거리라 함은 상하좌우 인접한 칸 중 이동가능한 칸으로만 이동하여 도달하기까지 거쳐야 하는 칸의 수가 최소가 되는 거리를 뜻합니다.

2. 만약 편의점에 도착한다면 해당 편의점에서 멈추게 되고, 이때부터 다른 사람들은 해당 편의점이 있는 칸을 지나갈 수 없게 됩니다. 격자에 있는 사람들이 모두 이동한 뒤에 해당 칸을 지나갈 수 없어짐에 유의합니다.

3. 현재 시간이 t분이고 t ≤ m를 만족한다면, t번 사람은 자신이 가고 싶은 편의점과 가장 가까이 있는 베이스 캠프에 들어갑니다. 여기서 가장 가까이에 있다는 뜻 역시 1에서와 같이 최단거리에 해당하는 곳을 의미합니다. 가장 가까운 베이스캠프가 여러 가지인 경우에는 그 중 행이 작은 베이스캠프, 행이 같다면 열이 작은 베이스 캠프로 들어갑니다. t번 사람이 베이스 캠프로 이동하는 데에는 시간이 전혀 소요되지 않습니다.

   이때부터 다른 사람들은 해당 베이스 캠프가 있는 칸을 지나갈 수 없게 됩니다. t번 사람이 편의점을 향해 움직이기 시작했더라도 해당 베이스 캠프는 앞으로 절대 지나갈 수 없음에 유의합니다. 마찬가지로 격자에 있는 사람들이 모두 이동한 뒤에 해당 칸을 지나갈 수 없어짐에 유의합니다.

아래와 같이 n = 5, m = 3, 베이스 캠프 4곳, 편의점 3곳이 주어진 경우에 대해서 생각해보겠습니다.

<img src="https://contents.codetree.ai/problems/2707/images/6e4ad191-c136-4855-a93a-201fc0bbdf63.png" width="50%" height="50%">

1분에는 격자 내에 아직 사람이 없기 때문에 1, 2번 행동은 진행되지 않으며 3번 행동부터 진행됩니다. 1번 사람이 가고 싶은 편의점과 가장 가까운 베이스캠프는 (2, 1)의 베이스캠프, (2, 5)의 베이스캠프 두 가지 입니다. 이 둘은 행이 같지만 (2, 1)의 베이스캠프가 열이 더 작기 때문에 해당 베이스캠프로 1번 사람은 이동하고, 앞으로 해당 칸으로는 사람이 절대 지나갈 수 없게 됩니다.



2분에는 1번 사람이 편의점을 향해 한 칸 움직이게 됩니다. 또, 2번 사람이 베이스 캠프에 도착합니다. 이 경우에도 최단 거리에 있는 베이스 캠프가 (4, 2), (5, 5) 두 가지인데, (4, 2)에 있는 베이스캠프가 행이 작기 때문에 (4, 2) 베이스캠프로 이동하게 됩니다.

<img src="https://contents.codetree.ai/problems/2707/images/2b49ee95-2be8-4869-83b4-5e69cbff7577.png" width="50%" height="50%">

3분에는 1번과 2번 사람 각각이 한 칸씩 이동하게 됩니다. 그 뒤 1번 사람이 편의점에 도착해, 앞으로 해당 칸으로는 사람이 절대 지나갈 수 없게 됩니다. 3번은 새로 베이스캠프에 도착하게 됩니다.

<img src="https://contents.codetree.ai/problems/2707/images/e3c91006-76c4-42b4-8401-7d152e26acbc.png" width="50%" height="50%">

이러한 과정을 반복하면 모든 사람이 편의점에 도착할 때까지 총 7분이 걸리게 됩니다. 그 과정은 아래와 같습니다.

<img src="https://contents.codetree.ai/problems/2707/images/e725e8ca-5f48-416f-89db-05c9f86f3213.png" width="50%" height="50%">

<img src="https://contents.codetree.ai/problems/2707/images/e31ee2d8-b896-448c-8670-a893f6307679.png" width="50%" height="50%">

<img src="https://contents.codetree.ai/problems/2707/images/ee1693a6-9ff3-408a-984d-920ece3867e6.png" width="50%" height="50%">

<img src="https://contents.codetree.ai/problems/2707/images/ac9e022b-8c3a-47df-8e0c-ea4b6617c6dd.png" width="50%" height="50%">

이미 사람들이 도착한 편의점이나 출발한 적이 있는 베이스캠프의 경우 움직일 때 절대 지나갈 수 없는 공간임을 유의합니다. (예시에서는 빨간색으로 표시되어 있습니다.)

사람들이 위와 같은 방식으로 움직일 때 총 몇 분 후에 모두 편의점에 도착하는지를 구하는 프로그램을 작성해보세요.

## 입력 형식

첫 번째 줄에는 격자의 크기 n과 사람의 수 m이 공백을 사이에 두고 주어집니다.

이후 n개의 줄에 걸쳐 격자의 정보가 주어집니다. 각 줄에 각각의 행에 해당하는 n개의 수가 공백을 사이에 두고 주어집니다.
0의 경우에는 빈 공간, 1의 경우에는 베이스캠프를 의미합니다.

이후 m개의 줄에 걸쳐 각 사람들이 가고자 하는 편의점 위치의 행 x, 열 y의 정보가 공백을 사이에 두고 주어집니다.

각 사람마다 가고 싶은 편의점의 위치는 겹치지 않으며, 편의점의 위치와 베이스캠프의 위치도 겹치지 않습니다.

- 2 ≤ n ≤ 15
- 1 ≤ m ≤ *min*(*n*2,30)
- m ≤ 베이스 캠프의 개수 ≤ *n*2−*m*

## 출력 형식

모든 사람이 편의점에 도착하는 시간을 출력하세요.

문제 조건에 의해 어떠한 사람이 원하는 편의점에 도달하지 못하게 되는 경우는 절대 발생하지 않음을 가정해도 좋습니다.
또한, 이동하는 도중 동일한 칸에 둘 이상의 사람이 위치하게 되는 경우 역시 가능함에 유의합니다.

## 풀이 방법

BFS 문제



**생각해봐야 하는 점**

I. *편의점 방향 이동*

1. **상 좌 우 하** 순서로 최단거리 탐색. 사람은 겹칠 수 있음. 사람들은 동시에 이동함
2. n번 사람이 편의점 위치 도착 시에는 다른 모든 사람은 해당 칸으로 이동할 수 없음. 이는 <span style="color: red">최단거리 탐색 시에도 영향을 미침</span>



II. *베이스 캠프 도착*

1)   편의점과 가장 가까운 베이스캠프 중 다른 사람이 가지 않았던 곳을 선택. 같은 곳이 있다면 행이 작은 곳, 행이 같다면 열이 작은 곳
    * 2차원배열을 (1, 1)부터 탐색해야 함



<hr/>

2차원 배열 MAP과, 사람 배열, 편의점 배열을 사용해서 문제를 해결하였다.

특히, n번 사람은 n번 편의점을 가야하기 때문에 1:1로 대응해서 풀었다.



(a) moveAllToStore 메소드 [문제 내 1번 행동]

1. 사람 배열 전체를 탐색하며 모든 사람을 이동시키는 역할
   * 배열 내 i번째 사람의 값이 null이라면 사람이 아직 들어온 것이 아니기 때문에 continue;
   * i번째 편의점에 이미 도착했다면 continue;
2. 현재 위치에서 4방향(상, 좌, 우, 하)을 이동하고, 그 위치에서 다시 bfs를 돌려 최단거리를 산정한다.
3. 산정된 최단거리로 사람을 옮겨줌



(b) cvsArriveCheck 메소드 [문제 내 2번 행동]

1. 사람 배열과 편의점 배열 전체를 순회하며 i번 사람과 i번 편의점 위치를 확인한다. 동일하면 i번 편의점 방문처리 및 MAP에 방문처리를 해줬다.



(c) goBasecamp 메소드 [문제 내 3번 행동]

1. 베이스캠프를 선택하는 역할. 편의점과 가장 가까운 최단거리를 구해야 하기 때문에 bfs 이용
2. 최단 베이스캠프가 같다면 행이 작은 게 우선, 행이 같다면 열이 작은 게 우선이므로, 2차원배열 (1, 1) 부터 (N, N) 까지 탐색하며 bfs를 돌림



(d) bfs 메소드 [(a), (c)에서 사용]

1. (r1, c1)에서 (r2, c2)로 이동하는 최단 거리를 구하는 역할

   * 처음에는 (r2, c2)에 도착하기만 하면 count 값을 리턴했고, 이 때문에 히든 테케에서 틀렸었음

     => (r2, c2)에 도달하는 최단거리를 큐가 끝날 때까지 갱신해 줘야 함



(e) checkEnd 메소드

1. 편의점이 모두 탐색되었다면 게임 종료



걸린 시간: 3시간

## 풀이 코드

<script src="https://gist.github.com/piacu/f0986598672b55760ea41584a76721e9.js"></script>


[ { "title": "[boj] 1759 암호 만들기", "url": "/posts/BOJ-1759-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "", "tags": "", "date": "2022-10-05 00:00:00 +0900", "snippet": "문제바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.입력첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.출력각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.예제 입력 14 6a t c i s w예제 출력 1acisacitaciwacstacswactwaistaiswaitwastwcistciswcitwistw풀이 방법import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class BOJ_1759_암호만들기 {\tstatic StringBuilder sb = new StringBuilder();\tstatic int L;\tstatic int C;\tstatic char[] pwChar;\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\t\t\tL = Integer.parseInt(st.nextToken());\t\tC = Integer.parseInt(st.nextToken());\t\t\t\tpwChar = new char[C];\t\t\t\tst = new StringTokenizer(br.readLine());\t\tfor (int i = 0; i &lt; pwChar.length; i++) {\t\t\tpwChar[i] = st.nextToken().charAt(0);\t\t}\t\tArrays.sort(pwChar);\t\t\t\tbacktrack(0, 0, new char[L]);\t\t\t\tSystem.out.println(sb.toString());\t}\t\tprivate static void backtrack(int idx, int x, char[] result) {\t\tif(idx == L) {\t\t\tif(!checkArr(result)) return;\t\t\t\t\t\tfor(int i=0; i&lt;result.length; i++) {\t\t\t\tsb.append(result[i]);\t\t\t}\t\t\tsb.append(\"\\n\");\t\t\t\t\t\treturn;\t\t}\t\t\t\tfor(int i=x; i&lt;C; i++) {\t\t\tresult[idx] = pwChar[i];\t\t\tbacktrack(idx+1, i+1, result);\t\t}\t\t\t\t}\t\tprivate static boolean checkArr(char[] result) {\t\tint moeum = 0;\t\tint jaeum = 0;\t\t\t\tfor (int i = 0; i &lt; result.length; i++) {\t\t\tif(result[i] == 'a' || result[i] == 'e' || result[i] == 'i' || result[i] == 'o' || result[i] == 'u') {\t\t\t\tmoeum++;\t\t\t} else {\t\t\t\tjaeum++;\t\t\t}\t\t}\t\t\t\tif(moeum &gt;= 1 &amp;&amp; jaeum &gt;=2) return true;\t\telse return false;\t}}백트래킹 문제이다. 1학기 때 교수님이 그려줬던 상태공간트리를 오랜만에 떠올려가며 문제를 풀었다.문제 중 모음이 한 개 이상 그리고 자음이 두 개 이상인 단어만 된다고 하는 걸 유념하고 문제를 풀면 될 듯하다." }, { "title": "[programmers] 가장큰수", "url": "/posts/Programmers-%EA%B0%80%EC%9E%A5%ED%81%B0%EC%88%98/", "categories": "", "tags": "", "date": "2022-10-02 00:00:00 +0900", "snippet": "문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.입출력 예 numbers return [6, 10, 2] “6210” [3, 30, 34, 5, 9] “9534330” 풀이 방법import java.util.*;class Solution { public String solution(int[] numbers) { String[] strNums = new String[numbers.length]; for(int i=0; i&lt;strNums.length; i++){ strNums[i] = Integer.toString(numbers[i]); } // comparator 기본 사용법 // Comparator&lt;String&gt; comp = (o1, o2) -&gt; (o2 + o1).compareTo(o1 + o2); // Arrays.sort(strNums, comp); // lambda, comparator 사용법 // Arrays.sort(strNums, new Comparator&lt;String&gt;() { // @Override // public int compare(String o1, String o2){ // return (o2 + o1).compareTo(o1 + o2); // } // }); // 람다식 사용 Arrays.sort(strNums, (a, b) -&gt; { return (b + a).compareTo(a + b); } ); if(strNums[0].equals(\"0\")) return \"0\"; return String.join(\"\", strNums); }}처음에는 순열로 구현했다가 테케 정도만 맞고 다 틀렸다ㅠㅠ하지만 이 문제는 순열이 아닌 정렬!자바에서는 comparator를 사용해서 쉽게 정렬을 구현할 수 있다." }, { "title": "[programmers] K번째수", "url": "/posts/Programmers-K%EB%B2%88%EC%A7%B8%EC%88%98/", "categories": "", "tags": "", "date": "2022-09-28 00:00:00 +0900", "snippet": "문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다.배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다.입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.풀이 방법import java.util.*;class Solution { public int[] solution(int[] array, int[][] commands) { int[] answer = new int[commands.length]; for(int i=0; i&lt;commands.length; i++){ int len = commands[i][1] - commands[i][0] + 1; int[] tmpArr = new int[len]; for(int j=0; j&lt;len; j++){ tmpArr[j] = array[commands[i][0] - 1 + j]; } tmpArr = sort(tmpArr); answer[i] = tmpArr[commands[i][2] - 1]; } return answer; } private int[] sort(int[] arr){ int tmp = 0; for(int i=0; i&lt;arr.length; i++){ for(int j=0; j&lt;arr.length; j++){ if(arr[i] &lt; arr[j]){ tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } } return arr; }}Collections.sort를 사용하려 했는데 안 되어서 버블정렬을 구현해서 풀었다.끝나고 다른 풀이를 보니 Arrays.sort로 하면 된다고 한다." }, { "title": "[boj] 1991 트리순회", "url": "/posts/BOJ-1991-%ED%8A%B8%EB%A6%AC%EC%88%9C%ED%9A%8C/", "categories": "", "tags": "", "date": "2022-09-27 00:00:00 +0900", "snippet": "문제이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.예를 들어 위와 같은 이진 트리가 입력되면, 전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식) 중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식) 후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)가 된다.입력첫째 줄에는 이진 트리의 노드의 개수 N(1 ≤ N ≤ 26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 알파벳 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현한다.출력첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.풀이 방법import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;public class BOJ_1026_보물 {\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint nums = Integer.parseInt(br.readLine());\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\tint answer = 0;\t\t\t\tList&lt;Integer&gt; A = new ArrayList&lt;&gt;();\t\tfor (int i = 0; i &lt; nums; i++) {\t\t\tA.add(Integer.parseInt(st.nextToken()));\t\t}\t\t\t\tst = new StringTokenizer(br.readLine());\t\t\t\tList&lt;Integer&gt; B = new ArrayList&lt;&gt;();\t\tfor (int i = 0; i &lt; nums; i++) {\t\t\tB.add(Integer.parseInt(st.nextToken()));\t\t}\t\t\t\tCollections.sort(A);\t\tCollections.sort(B, Collections.reverseOrder());\t\t\t\tfor (int i = 0; i &lt; nums; i++) {\t\t\tanswer += A.get(i) * B.get(i);\t\t}\t\tSystem.out.println(answer);\t}}B의 숫자가 클수록 A를 작은 수로 매칭하도록 Comparable을 썼는데 다 필요없고 A를 오름차순 정렬, B를 내림차순 정렬 하면 되는 문제였다. ㅡㅡ;;B를 재배열하면 안된다에서 속았다…" }, { "title": "[boj] 1026 보물", "url": "/posts/BOJ-1026-%EB%B3%B4%EB%AC%BC/", "categories": "", "tags": "", "date": "2022-09-19 00:00:00 +0900", "snippet": "문제옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.S = A[0] × B[0] + … + A[N-1] × B[N-1]S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.S의 최솟값을 출력하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.출력첫째 줄에 S의 최솟값을 출력한다.풀이 방법import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;public class BOJ_1026_보물 {\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint nums = Integer.parseInt(br.readLine());\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\tint answer = 0;\t\t\t\tList&lt;Integer&gt; A = new ArrayList&lt;&gt;();\t\tfor (int i = 0; i &lt; nums; i++) {\t\t\tA.add(Integer.parseInt(st.nextToken()));\t\t}\t\t\t\tst = new StringTokenizer(br.readLine());\t\t\t\tList&lt;Integer&gt; B = new ArrayList&lt;&gt;();\t\tfor (int i = 0; i &lt; nums; i++) {\t\t\tB.add(Integer.parseInt(st.nextToken()));\t\t}\t\t\t\tCollections.sort(A);\t\tCollections.sort(B, Collections.reverseOrder());\t\t\t\tfor (int i = 0; i &lt; nums; i++) {\t\t\tanswer += A.get(i) * B.get(i);\t\t}\t\tSystem.out.println(answer);\t}}B의 숫자가 클수록 A를 작은 수로 매칭하도록 Comparable을 썼는데 다 필요없고 A를 오름차순 정렬, B를 내림차순 정렬 하면 되는 문제였다. ㅡㅡ;;B를 재배열하면 안된다에서 속았다…" }, { "title": "[boj] 14425 문자열집합", "url": "/posts/BOJ-14425-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%A7%91%ED%95%A9/", "categories": "", "tags": "", "date": "2022-09-18 00:00:00 +0900", "snippet": "문제총 N개의 문자열로 이루어진 집합 S가 주어진다.입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 프로그램을 작성하시오.입력첫째 줄에 문자열의 개수 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000)이 주어진다.다음 N개의 줄에는 집합 S에 포함되어 있는 문자열들이 주어진다.다음 M개의 줄에는 검사해야 하는 문자열들이 주어진다.입력으로 주어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다.출력첫째 줄에 M개의 문자열 중에 총 몇 개가 집합 S에 포함되어 있는지 출력한다.풀이 방법import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class BOJ_14425_문자열집합 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\t\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\tint answer = 0;\t\t\t\tString[] set = new String[N];\t\tfor (int i = 0; i &lt; set.length; i++) {\t\t\tset[i] = br.readLine();\t\t}\t\tString[] inputs = new String[M];\t\tfor (int i = 0; i &lt; inputs.length; i++) {\t\t\tinputs[i] = br.readLine();\t\t}\t\t\t\tfor (int i = 0; i &lt; set.length; i++) {\t\t\tfor (int j = 0; j &lt; inputs.length; j++) {\t\t\t\tif(set[i].equals(inputs[j])) {\t\t\t\t\tanswer++;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t}\t\t}\t\tSystem.out.println(answer);\t}\t}주어진 문자열과 일치하는 문자열의 개수를 구하는 문제이다.포함되어 있는 문자열 아닌 것을 주의하자." }, { "title": "[programmers] 게임 맵 최단거리", "url": "/posts/Programmers-%EA%B2%8C%EC%9E%84-%EB%A7%B5-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/", "categories": "", "tags": "", "date": "2022-09-15 00:00:00 +0900", "snippet": "문제 설명ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다. 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다. 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.제한사항 maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다. n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다. maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다. 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.입출력 예 maps answer [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] 11 [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] -1 입출력 예 설명입출력 예 #1주어진 데이터는 다음과 같습니다.캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.입출력 예 #2문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.풀이 방법import java.util.*;class Solution { int[] dr = {1,-1,0,0}; int[] dc = {0,0,-1,1}; public int solution(int[][] maps) { int answer = bfs(0, 0, maps); return answer; } public int bfs(int sr, int sc, int[][] maps){ Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); int res = Integer.MAX_VALUE; q.add(new int[] {sr, sc, 1}); while(!q.isEmpty()){ int[] loc = q.poll(); int r = loc[0]; int c = loc[1]; int cnt = loc[2]; if(r == maps.length-1 &amp;&amp; c == maps[0].length-1){ return cnt; } for(int i=0; i&lt;4; i++){ int nr = r + dr[i]; int nc = c + dc[i]; if(nr&gt;=0 &amp;&amp; nr&lt;maps.length &amp;&amp; nc&gt;=0 &amp;&amp; nc&lt;maps[0].length &amp;&amp; maps[nr][nc] == 1){ maps[nr][nc] = 0; q.add(new int[]{nr, nc, cnt+1}); } } } return -1; }}먼저, 프로그래머스는 IDE를 제공하지만 자동완성 기능은 사용할 수 없어 Queue와 LinkedList를 사용하기 위해 java.util.* 를 import 했다.일반적인 BFS 문제이다. 내가 이동한 곳은 벽으로 바꾸어서(1 -&gt; 0) 방문 배열을 사용하지 않도록 하였다." }, { "title": "[programmers] 타겟 넘버", "url": "/posts/Programmers-%ED%83%80%EA%B2%9F-%EB%84%98%EB%B2%84/", "categories": "", "tags": "", "date": "2022-09-14 00:00:00 +0900", "snippet": "문제 설명n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.제한사항 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다.입출력 예 numbers target return [1, 1, 1, 1, 1] 3 5 [4, 1, 2, 1] 4 2 입출력 예 설명입출력 예 #1문제 예시와 같습니다.입출력 예 #2+4+1-2+1 = 4+4-1+2-1 = 4 총 2가지 방법이 있으므로, 2를 return 합니다.풀이 방법class Solution { int answer = 0; public int solution(int[] numbers, int target) { permutation(0, numbers, new boolean[numbers.length], target); return answer; } public void permutation(int index, int[] nums, boolean[] v, int tgt){ if(index == nums.length){ int sum = 0; for(int i=0; i&lt;v.length; i++){ if(v[i]){ sum += nums[i]; } else { sum -= nums[i]; } } if(sum == tgt){ answer++; } return; } v[index] = true; permutation(index+1, nums, v, tgt); v[index] = false; permutation(index+1, nums, v, tgt); }}dfs 분류로 되어 있는 문제인데 부분집합으로 풀었다.선택한(true) 숫자는 +로, 선택하지 않은 숫자는 -로 설정해서 나온 값을 모두 더한 후 타겟 넘버와 비교했다." }, { "title": "[boj] 2231 분해합", "url": "/posts/BOJ-2231-%EB%B6%84%ED%95%B4%ED%95%A9/", "categories": "", "tags": "", "date": "2022-09-08 00:00:00 +0900", "snippet": "문제어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.입력첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.출력첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.풀이 방법import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class BOJ_2231_분해합 {\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint num = Integer.parseInt(br.readLine());\t\t\t\tfor (int i = 1; i &lt;= num; i++) {\t\t\tint sum = i + addNum(i);\t\t\tif(sum == num) {\t\t\t\tSystem.out.println(i);\t\t\t\treturn;\t\t\t}\t\t}\t\tSystem.out.println(0);\t}\tprivate static int addNum(int num) {\t\treturn num%10 + num/10%10 + num/100%10 + num/1000%10 + num/10000%10 + num/100000%10 + num/1000000%10;\t}}숫자를 한 자리씩 나누는 걸 알면 금방 풀 수 있는 쉬운 문제이다.알게 된 점은 나눗셈 연산을 먼저 해도, 나머지 수 계산을 먼저 해도 가능하다는 점 이다.ex)십의 자리의 수 : num/10%10 == num%100/10백의 자리의 수 : num/100%10 == num%1000/100" }, { "title": "0907 회고", "url": "/posts/0907-%ED%9A%8C%EA%B3%A0/", "categories": "", "tags": "", "date": "2022-09-07 00:00:00 +0900", "snippet": "Vol. 1새로운 프로젝트(특화 프로젝트)에 들어가게 됐다.인공지능(영상) 을 경험해 보고 싶어 이쪽으로 발길을 향했지만… 결코 쉽지 않아(개념이 너무 어렵다) 백엔드를 구축하면서 차차 공부하며 AI팀을 도와주는 것으로 정했다!하지만 반년 넘게 자바만 쓰던 내가 파이썬이랑 장고를 써야 되어서 오늘부터 공부를 시작하게 되고오랜만에 접하는 파이썬이라 신선해서 좋았지만 객체지향 으로 알고있던 파이썬이 너무 객체지향스럽지 않은 느낌이 들었다.그 이유는 한 블로그에서 찾을 수 있었다.파이썬도 처음 개발할 때는 통계나 인공지능으로 쓰일 줄 알았겠는가… 역시 사람일 모른다고 언제나 준비해야겠다. 더욱 노력이 필요한 시기다.Vol. 2어제부터 알고리즘을 다시 잡았다…웹 백엔드에 대한 감을 어느정도 잡은 거 같기도 하고, 알고리즘 스터디를 시작했기 때문이다!열심히 하고, 잘 하는 다른 3명의 팀원들과 하는 알스, 일주일에 무조건 2문제를 풀지 않으면 5천원이라는 벌금을 내기로 했다.마음 먹은 만큼 꾸준히 노력해야지!과연 첫번째 벌금 당첨자는 누구일까 . . . ^ㅡ^이 도전은 취업할 때까지 계속 되었으면 한다. 나는 잘할거야~~" }, { "title": "Jpa 공부", "url": "/posts/JPA-%EA%B3%B5%EB%B6%80/", "categories": "", "tags": "", "date": "2022-07-21 00:00:00 +0900", "snippet": "JPA는 표준 ORM(Object-Relational Mapping)으로 Hibernate라는 ORM 프레임워크를 사용해서 구현한다.EntityManagerFactory 는 리소스를 많이 사용하기 때문에 하나만 생성에서 애플리케이션 내부에서 전체 공유해서 사용EntityManager은 한번 쓰고 버려야 함. 여러 쓰레드에서 공유하면 안된다.JPA의 모든 데이터 변경은 트랜잭션 안에서 실행JPQL SQL를 추상화한 객체지향 버전JPQL : 엔티티 객체를 대상으로 쿼리SQL : 데이터베이스 대상으로 쿼리영속성 컨텍스트JPA를 이해하는 데 가장 중요한 용어엔티티를 영구 저장하는 환경영속성 컨텍스트는 논리적인 개념엔티티 매니저를 통해 영속성 컨텍스트에 접근 엔티티의 생명주기 비영속(new/transient)​\t영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속(managed)​\t영속성 컨텍스트에 관리되는 상태 준영속(detached)​\t영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed)​\t삭제된 상태영속성 컨텍스트란?Entity와 DB 사이를 연결해 주는 임시 저장 공간이라고 생각하면 쉽다. Java – 영속성 컨텍스트(1차 캐시) – DB데이터를 저장할 때 영속성 컨텍스트에 저장되고,` 데이터를 요청할 때 영속성 컨텍스트에 저장된다.`이렇게 해서 여러번 쿼리를 날릴 필요 없이 필요한 쿼리만 전송할 수 있다.(1차 캐시에 해당 데이터가 있으면 그것을 사용하면 되기 때문에)영속성 컨텍스트(1차 캐시)는 트랜잭션 내에 있으며 트랜잭션이 초기화되면 데이터가 삭제된다.쿼리를 실행하면 1차 캐시에 저장되고, 트랜잭션이 끝날 때 쿼리가 DB로 날라가서 정보를 저장/요청 한다. 쓰기 지연 변경 감지플러시 flush()영속성 컨텍스트의 변경내용을 DB에 동기화하는 작업플러시가 되는 경우 em.flush() - 직접호출 transaction commit - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출주의점 : 영속성 컨텍스트를 비우지 않음!준영속 상태영속성 콘텍스트를 초기화 하는 것영속 상태의 엔티티가 영속성 컨텍스트에서 분리엔티티 @EntityJPA가 관리한다테이블과 매핑할 클래스 주의사항기본생성자 필수final, enum, interface, inner 클래스 사용 X엔티티 매핑 어노테이션 어노테이션 설명 @Column 컬럼 @Temporal 날짜 타입 @Enumerated enum 타입 @Lob BLOB, CLOB 타입 매핑 @Transient 특정 필드를 Table 컬럼에서 제외 권장하는 식별자 전략기본 키 제약 조건: null X, 유일, 변하면 안된다.미래까지 이 조건을 만족하는 자연키는 찾기 어려움. 대체키 사용권장 : Long형 + 대체키 + 키 생성전략 사용(auto increment, sequence 전략 등..)엔티티 연관관계다중성, 방향성, 연관관계 주인 설정을 해주어야 함테이블에서는 기본적으로 양방향 연관관계가 적용됨 (Join)하지만, 객체에서는 단방향 연관관계임이 상황에서 양방향으로 설정했을 경우 어떤 테이블 기준으로 데이터를 삭제하면 그것에 관련된 데이터들을 다 삭제할 것인가? 라는 물음에서 답으로 연관관계 주인 설정이 나타남 양방향 매핑 규칙객체의 두 관계 중 하나의 연관 관계를 주인으로 지정주인만이 외래 키 관리(등록, 수정)주인이 아닌 쪽은 읽기만 가능주인은 mappedby 속성 X외래 키(FK)가 있는 곳을 주인을 설정해 준다.'다' 쪽이 주인이다.@ManyToOne 은 항상 주인이다.JpaRepository Read : find** 로 시작 Delete : delete** 로 시작 Create : save Update : 객체 조회 후 값 변경 그리고 다시 saveBuilder 패턴에서 객체 생성할 때 Tip설계자가 객체를 생성할 떄 순서를 고려하지 않을 때를 방지, 생성자 앞에 @Builder 어노테이션을 작성." }, { "title": "0719 회고", "url": "/posts/0719-%ED%9A%8C%EA%B3%A0/", "categories": "", "tags": "", "date": "2022-07-19 00:00:00 +0900", "snippet": "Spring Boot project 생성 및 빌드 자동화 도구 고르기 스프링 부트 프로젝트를 만드는 것 까지는 정말 쉬운데… maven만을 사용하다가 gradle 을 사용하게 되니 처음 알게 된게 있었다. maven «« gradleMaven에 대비하여 Gradle의 장점은.. 속도 빠름(10~100배) 어떤 라이브러리가 있는지 보려면 스크롤 한~~~참 내려야 하는 xml 파일 안 봐도 됨(개인적으로 이게 가장 큼) Java 랑 비슷한 Groovy 라는 언어를 써서 친숙한 환경임현업에서도 Gradle로 많이 넘어가는 추세라고 한다. 몇년 뒤에는 새 프로젝트 생성 시에 maven을 선택할 수 없을지도~Spring JPASpring JPA를 사용하기 위해서는 META-INF/persistence.xml 에서 설정을 해주어야 한다.하지만 가독성이 떨어지는 xml 파일을 생성하기 싫었고, 기본으로 생성되는 application.properties 파일에다가 작성하고 싶어서 찾아보다가 application.yml 파일에 작성하는 블로그를 찾게 되었다!!https://devgoat.tistory.com/15게다가 application.properties -&gt; application.yml 로 변환하는 쉬운 방법도 알려준다그리고 아무리 변경해도, 아무리 찾아봐도 persistence.xml 에 작성하지 않고서는 persistenceUnitName을 찾을 수 없다고 해서 결국 xml 파일을 만들게 되었다…수 시간동안 삽질해서 얻은 게 없는… ㅠ.ㅠxml 파일 설정 후에 controller, service, repository 등을 만들었는데 jpa 쿼리가 보내지질 않는다.persistence.xml 내 database 옵션 중 hibernate.show_sql 을 켜면 콘솔에 보내지는 sql이 표시되는데콘솔에는 아 무 고 토 읍 다.게다가 오류조차 뜨지 않는다!!!으아~~ 내일은 무조건 해결한다." }, { "title": "Github Page 개설 및 후기", "url": "/posts/Github-Page-%EA%B0%9C%EC%84%A4-%EB%B0%8F-%ED%9B%84%EA%B8%B0/", "categories": "", "tags": "", "date": "2022-06-28 00:00:00 +0900", "snippet": " 안녕하세요. Github Page 를 사용한 블로그를 개설하였습니다. 여기에는 여러 가지 개발 일지나 해결한 문제 등을 적는 기술블로그로 사용하고자 합니다. 첫번째 게시물은 개설을 자축하며 이 블로그를 만들기까지 헤매었던 것들을 적어보려 합니다.🎉 개설을 축하합니다~ 🎉(만들어놓고 방치하는 게으름뱅이가 되지 않기를… 😀)Github Page를 만들기까지의 과정나만의 블로그를 만들어서 운영하고 싶었는데 피차 미루다가 오늘은 무조건 마무리해야겠다고 마음먹고 시작!!개발자들이 많이 사용한다는 Tistory나 Velog 와 고민하다가 github page의 장점인 자유로운 커스터마이징의 매력을 보고 깃허브 페이지를 선택했습니다.하지만 자유롭다는 것은 그만큼 큰 책임(일)이 따른다는 진리는 역시 틀린 말 하나 없는 것 같군요.jekyll를 사용한 정적 페이지를 만들기로 결정하고 Ruby, jekyll 를 설치하고 테마는 동료분께 추천받은 chirpy를 사용했습니다.chirpy 를 fork 해서 저장소로 가져온 뒤 clone 해서 local 에서 작업하였습니다.clone 한 다음 chirpy 공식문서의 Option 2를 따라하면 쉽게 됩니다.(실수로 처음에 chirpy starter를 fork해서 작업했더니 tools 폴더에 아무것도 없어서 여러번 지웠다가 만들었습니다…)위 명령어를 실행 후에 _config.yml 파일을 내 정보에 맞게 열심히 세팅해주고 모든 세팅이 끝난 후 origin 으로 push 를 하면 완료됩니다:exclamation: 였으면 좋겠지만 개발자의 숙명은 역시 버그잡기 아니겠습니까.많은 시간을 소비하게 만든 인증 오류 ! [remote rejected] master -&gt; master (refusing to allow an OAuth App to create or update workflow .github/workflows/pages-deploy.yml without workflow scope) error: failed to push some refs to ‘https://github.com/piacu/piacu.github.io.git’해석하면 OAuth 앱이 workflow 범위 없이 ~~/pages-deploy.yml 워크플로를 생성하거나 업데이트 걸 거부한다. 라는데…구글링의 결과는 다 깃허브의 Personal access tokens를 수정해보라고 하지만 에러 메세지는 달라지지 않았습니다.그러다가 깃허브 커뮤에서 찾은 단비같은 개발자의 답변…https://github.community/t/refusing-to-allow-an-integration-to-create-or-update/16326Github Desktop과 같은 도구를 업데이트하면 애플리케이션 토큰을 요청할 수 있다!!!바로 깃허브 데스크탑 설치~~ 결과는 푸시 성공!!정말 몇시간을 삽질했는 지 모르겠지만 성공했으니 기분이 그만큼 더 좋군요 🤩저같이 삽질하는 사람에게 이 링크를 보내줘야 겠습니다 ~포스팅 끝!" } ]
